diff --git a/include/framework_collision/fk_collision.h b/include/framework_collision/fk_collision.h
index a43a57c..80699e8 100755
--- a/include/framework_collision/fk_collision.h
+++ b/include/framework_collision/fk_collision.h
@@ -22,7 +22,7 @@
 ** fk_collision.c
 ** ****************************************************************************
 */
-t_color3		ft_trace_ray(t_object *arr, t_object *light, t_ray ray, int depth, float *dist_out, t_env env);
+t_color3		ft_trace_ray(t_object *arr, t_object *light, t_ray ray, int depth, float *dist_out, t_env env, float refr);
 void		ft_render(t_env env);
 
 /*
diff --git a/scene_test.json b/scene_test.json
index a25b57d..c2d0d40 100644
--- a/scene_test.json
+++ b/scene_test.json
@@ -12,31 +12,13 @@
       "pos":{
         "x":0,
         "y":0.4,
-        "z":4
+        "z":50
       },
-      "reflection_index": 0.0,
+      "reflection_index": 1.0,
       "refraction": 0.0,
       "refraction_index": 0.0,
       "diffuse": 0.0,
-      "radius": 0.50
-    },
-    {
-      "type":"SPHERE",
-      "color":{
-        "red":255,
-        "green":255,
-        "blue":255
-      },
-      "pos":{
-        "x":0,
-        "y":0,
-        "z":2
-      },
-      "reflection_index": 0.0,
-      "refraction": 0.6,
-      "refraction_index": 1.0,
-      "diffuse": 0.3,
-      "radius":0.2
+      "radius": 1.50
     },
     {
       "comment":"sol",
@@ -104,7 +86,7 @@
       "normal":{
         "x":0,
         "y":0,
-        "z":-1
+        "z":1
       }
     },
     {
@@ -120,7 +102,7 @@
         "y":0,
         "z":0
       },
-      "reflection_index": 0.9,
+      "reflection_index": 0.3,
       "refraction": 0.0,
       "refraction_index": 0.0,
       "diffuse": 0.1,
@@ -165,7 +147,7 @@
       "pos": {
         "x": 0,
         "y": 0,
-        "z": 100
+        "z": 0
       },
       "reflection_index": 0.0,
       "refraction": 0.0,
diff --git a/src/framework_collision/fk_collision.c b/src/framework_collision/fk_collision.c
index 290fe1b..0a834b2 100644
--- a/src/framework_collision/fk_collision.c
+++ b/src/framework_collision/fk_collision.c
@@ -73,39 +73,43 @@ static	t_color3	getfinalcolor(t_object *light, t_intersect inter)
 	return (color_new(17, 25, 37));
 }
 
-t_ray	create_reflection(t_ray ray, t_intersect inter)
+t_bool create_reflection(t_ray *newray, t_ray ray, t_intersect inter)
 {
-	t_ray		newray;
 	t_vector3 norm;
 
-	newray.dir = vector_mul(inter.v_normal, (2.0f * vector_dotproduct(ray.dir, inter.v_normal)));
-	newray.dir = vector_unit(vector_substract(ray.dir, newray.dir));
-	newray.pos = vector_sum(inter.pos, vector_mul(newray.dir, 1e-4));
-	return (newray);
+	newray->dir = vector_mul(inter.v_normal, (2.0f * vector_dotproduct(ray.dir, inter.v_normal)));
+	newray->dir = vector_unit(vector_substract(ray.dir, newray->dir));
+	newray->pos = vector_sum(inter.pos, vector_mul(newray->dir, 1e-4));
+	return (TRUE);
 }
 
-t_ray	create_refraction(t_ray ray, t_intersect inter)
+t_bool	create_refraction(t_ray *newray, t_ray ray, t_intersect inter, float refract)
 {
-	float		eta;
 	float		cosi;
+	float		cost;
 	float		k;
-	t_ray		newray;
-	t_vector3	norm;
-
-	eta = vector_dotproduct(ray.dir, inter.v_normal) > 0 ? 1 / 1.1 : 1;
-	norm = inter.v_normal;
-	if (eta != 1.1)
-		norm = vector_mul(inter.v_normal, -1);
-	cosi = -vector_dotproduct(norm, ray.dir);
-	k = 1.0f - eta * eta * (1.0f - cosi * cosi);
-	newray.dir = vector_mul(norm, (eta * cosi - sqrtf(k)));
-	newray.dir = vector_sum(vector_mul(ray.dir, eta), newray.dir);
-	newray.dir = vector_unit(newray.dir);
-	newray.pos = vector_sum(inter.pos, vector_mul(newray.dir, 1e-4));
-	return (newray);
+	float		ref;
+	
+	ref = 1.0 / inter.obj->refraction_index;
+	if (vector_dotproduct(ray.dir, inter.v_normal) > 0)
+	{
+		inter.v_normal = vector_mul(inter.v_normal, -1);
+		ref = 1.0;
+	}
+	cosi = -vector_dotproduct(inter.v_normal, ray.dir);
+	k = 1.0f - ref * ref * (1.0f - cosi * cosi);
+	if (k > 0.0f)
+	{
+		newray->dir = vector_mul(ray.dir, ref);
+		newray->dir = vector_sum(newray->dir, vector_mul(inter.v_normal, (ref * cosi - sqrt(k))));
+		newray->dir = vector_unit(newray->dir);
+		newray->pos = vector_sum(inter.pos, vector_mul(newray->dir, 1e-4f));
+		return (TRUE);
+	}
+	return (FALSE);
 }
 
-t_color3	ft_trace_ray(t_object arr[16], t_object light[16], t_ray ray, int depth, float *dist_out, t_env env)
+t_color3	ft_trace_ray(t_object arr[16], t_object light[16], t_ray ray, int depth, float *dist_out, t_env env, float refract)
 {
 	t_ray			reflection;
 	t_ray			refraction;
@@ -122,30 +126,32 @@ t_color3	ft_trace_ray(t_object arr[16], t_object light[16], t_ray ray, int depth
 	outcolor = color_new(17, 25, 37);
 	i = -1;
 	inter.obj = NULL;
+	//dprintf(2, "test entree de trace refract : %f\n", refract);
 	while (++i < 16 && arr[i].type != DEFAULT)
-		if (env.fctinter[arr[i].type](ray, arr + i, &dist))
-			if ((!inter.obj || dist < *dist_out) && dist > 0.01f)
+		if (env.fctinter[arr[i].type](ray, arr + i, &dist) && (dist > 1e-6f))
+		{
+	//		dprintf(2, "Lecture d'une intersection obj[%s] = %f\n", arr[i].type == SPHERE ? "SPHERE" : "PLANE", dist);
+			if ((!inter.obj || dist < *dist_out) )
 			{
 				inter.obj = &arr[i];
 				*dist_out = dist;
 			}
-	if (inter.obj)
+		}
+	if (inter.obj && depth < g_depth)
 	{
+		//dprintf(2, "test apres collision de trace refract : %f Obj[%s]\n", refract, inter.obj->type == SPHERE ? "SPHERE" : "PLANE");
 		inter.pos = create_intersect(ray, *dist_out);
 		inter.v_normal = env.fctnormal[inter.obj->type](ray, inter.pos, inter.obj);
 		outcolor = getfinalcolor(light, inter);
-		if (inter.obj->reflection_index > 0.0f || inter.obj->refraction_index > 0.0f)
+		if (inter.obj->reflection_index > 0 && create_reflection(&reflection, ray, inter))
 		{
-			reflection = create_reflection(ray, inter);
-			ref_color = ft_trace_ray(arr, light, reflection, depth + 1, NULL, env);
-			if (vector_magnitude(vector_substract(ray.pos, inter.pos)) > 1e-4f)
-				outcolor = vector_sum(outcolor, vector_mul(ref_color, inter.obj->reflection_index));
-			if (inter.obj->refraction_index > 0.0f && depth < g_depth)
-			{
-				refraction = create_refraction(ray, inter);
-				ref_color = ft_trace_ray(arr, light, refraction, depth + 1, NULL, env);
-				outcolor = vector_sum(outcolor, vector_mul(ref_color, inter.obj->refraction_index));
-			}
+			ref_color = ft_trace_ray(arr, light, reflection, depth + 1, NULL, env, refract);
+			outcolor = vector_sum(outcolor, vector_mul(ref_color, inter.obj->reflection_index));
+		}
+		if (inter.obj->refraction_index > 0 && create_refraction(&refraction, ray, inter, refract))
+		{
+			ref_color = ft_trace_ray(arr, light, refraction, depth + 1, NULL, env, inter.obj->refraction_index);
+			outcolor = vector_sum(outcolor, vector_mul(ref_color, inter.obj->refraction_index));
 		}
 	}
 	return (outcolor);
@@ -188,11 +194,12 @@ void		ft_render(t_env env)
 			ray.dir.y = (1. - 2. * (y * invH)) * angle;
 			ray.dir.z = 1;
 			ray.dir = vector_unit(ray.dir);
-			rgba = ft_trace_ray(arr, light, ray, 0, NULL, env);
+			rgba = ft_trace_ray(arr, light, ray, 0, NULL, env, 1.00);
 			ft_put_pixel_to_image(env.img, x, y, rgba);
 			x++;
 		}
 		y++;
 	}
 	mlx_put_image_to_window(env.mlx, env.win, env.img.ptr, 0, 0);
+	dprintf(1, "FIN\n");
 }
diff --git a/src/framework_shape/fk_intersect_sphere.c b/src/framework_shape/fk_intersect_sphere.c
index acc6e99..8b3322c 100644
--- a/src/framework_shape/fk_intersect_sphere.c
+++ b/src/framework_shape/fk_intersect_sphere.c
@@ -16,17 +16,28 @@
 t_bool			intersect_sphere(t_ray ray, t_sphere* obj, float *t)
 {
 	t_vector3		etoc;
-	float			radius;
-	float			vector_radius;
+	float			b;
+	float			d;
+	float			t1;
+	float			t2;
 
 	etoc = vector_substract(obj->pos, ray.pos);
-	if ((vector_radius = vector_dotproduct(etoc, ray.dir)) < 0.)
+	b = vector_dotproduct(ray.dir, etoc);
+	d = b*b - vector_dotproduct(etoc, etoc) + SQUARE(obj->radius);
+	if (d < 0.0f)
 		return (FALSE);
-	*t = vector_dotproduct(etoc, etoc) - SQUARE(vector_radius);
-	if (*t > (radius = SQUARE(obj->radius)))
-		return (FALSE);
-	*t = sqrt(radius - *t);
-	*t = FT_MIN((vector_radius - *t), (vector_radius + *t));
-	return (TRUE);
+	t1 = b - sqrt(d);
+	t2 = b + sqrt(d);
+	if (t1 > 0.001f)
+	{
+		*t = t1;
+		return (TRUE);
+	}
+	if (t2 > 0.001f)
+	{
+		*t = t2;
+		return (TRUE);
+	}
+	return (FALSE);
 }
 
